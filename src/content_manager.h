/*MT*
    
    MediaTomb - http://www.mediatomb.org/
    
    content_manager.h - this file is part of MediaTomb.
    
    Copyright (C) 2005 Gena Batyan <bgeradz@mediatomb.org>,
                       Sergey Bostandzhyan <jin@mediatomb.org>
    Copyright (C) 2006 Gena Batyan <bgeradz@mediatomb.org>,
                       Sergey Bostandzhyan <jin@mediatomb.org>,
                       Leonhard Wimmer <leo@mediatomb.org>
    
    MediaTomb is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
    
    MediaTomb is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with MediaTomb; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    
    $Id$
*/

/// \file content_manager.h
#ifndef __CONTENT_MANAGER_H__
#define __CONTENT_MANAGER_H__

#include "common.h"
#include "cds_objects.h"
#include "storage.h"
#include "dictionary.h"
#include "sync.h"
#include "autoscan.h"
#include "timer.h"

#ifdef HAVE_JS
#include "scripting/scripting.h"
#endif

class ContentManager;

typedef enum task_id_t
{
    Invalid,
    AddFile,
    RemoveObject,
    LoadAccounting,
    RescanDirectory
};

class CMTask : public zmm::Object
{
protected:
    ContentManager *cm;
    zmm::String description;
    task_id_t taskID;
    bool valid;
    
public:
    CMTask();
    virtual void run() = 0;
    void setDescription(zmm::String description);
    zmm::String getDescription();
    task_id_t getID();
    bool isValid();
    void invalidate();
};

class CMAddFileTask : public CMTask
{
protected:
    zmm::String path;
    bool recursive;
    bool hidden;
public:
    CMAddFileTask(zmm::String path, bool recursive=false, bool hidden=false);
    zmm::String getPath();
    virtual void run();
};

class CMRemoveObjectTask : public CMTask
{
protected:
    int objectID;
    bool all;
public:
    CMRemoveObjectTask(int objectID, bool all);
    virtual void run();
};

class CMLoadAccountingTask : public CMTask
{
public:
    CMLoadAccountingTask();
    virtual void run();
};

class CMRescanDirectoryTask : public CMTask
{
protected: 
    int objectID;
    int scanID;
    scan_mode_t scanMode;
public:
    CMRescanDirectoryTask(int objectID, int scanID, scan_mode_t scanMode);
    virtual void run();
};

class CMAccounting : public zmm::Object
{
public:
    CMAccounting();
public:
    int totalFiles;
};

/*
class DirCacheEntry : public zmm::Object
{
public:
    DirCacheEntry();
public:
    int end;
    int id;
};

class DirCache : public zmm::Object
{
protected:
    zmm::Ref<zmm::StringBuffer> buffer;
    int size; // number of entries
    int capacity; // capacity of entries
    zmm::Ref<zmm::Array<DirCacheEntry> > entries;
public:
    DirCache();
    void push(zmm::String name);
    void pop();
    void setPath(zmm::String path);
    void clear();
    zmm::String getPath();
    int createContainers();
};
*/

class ContentManager : public TimerSubscriber
{
public:
    virtual ~ContentManager();
    void shutdown();

    virtual void timerNotify(int id);

    static zmm::Ref<ContentManager> getInstance();

    zmm::Ref<CMAccounting> getAccounting();
    zmm::Ref<CMTask> getCurrentTask();
    
    /* the functions below return true if the task has been enqueued */
    
    /* sync/async methods */
    void loadAccounting(bool async=true);
    void addFile(zmm::String path, bool recursive=true, bool async=true, bool hidden=false, bool lowPriority=false);
    int ensurePathExistence(zmm::String path);
    void removeObject(int objectID, bool async=true, bool all=false);
//    void rescanDirectory(int objectID, scan_level_t scanLevel = BasicScan);   
    
    /// \brief Updates an object in the database using the given parameters.
    /// \param objectID ID of the object to update
    /// \param parameters key value pairs of fields to be updated
    void updateObject(int objectID, zmm::Ref<Dictionary> parameters);

    zmm::Ref<CdsObject> createObjectFromFile(zmm::String path, bool magic=true);

    /// \brief Adds an object to the database.
    /// \param obj object to add
    ///
    /// parentID of the object must be set before this method.
    /// The ID of the object provided is ignored and generated by this method    
    void addObject(zmm::Ref<CdsObject> obj);

    /// \brief Adds a virtual container chain specified by path.
    /// \param container path separated by '/'. Slashes in container
    /// titles must be escaped.
    /// \return ID of the last container in the chain.
    int addContainerChain(zmm::String chain);
    
    /// \brief Adds a virtual container specified by parentID and title
    /// \param parentID the id of the parent.
    /// \param title the title of the container.
    /// \param upnpClass the upnp class of the container.
    void addContainer(int parentID, zmm::String title, zmm::String upnpClass);
    
    /// \brief Updates an object in the database.
    /// \param obj the object to update
    void updateObject(zmm::Ref<CdsObject> obj);

    /// \brief Updates an object in the database using the given parameters.
    /// \param objectID ID of the object to update
    ///
    /// Note: no actions should be performed on the object given as the parameter.
    /// Only the returned object should be processed. This method does not save
    /// the returned object in the database. To do so updateObject must be called
    zmm::Ref<CdsObject> convertObject(zmm::Ref<CdsObject> obj, int objectType);

    /// \brief Gets an AutocsanDirectrory from the watch list.
    zmm::Ref<AutoscanDirectory> getAutoscanDirectory(int scanID, scan_mode_t scanMode);

    /// \brief Removes an AutoscanDirectrory (found by scanID) from the watch list.
    void removeAutoscanDirectory(int scanID, scan_mode_t scanMode);
    /// \brief Removes an AutoscanDirectrory (found by location) from the watch list.
    void removeAutoscanDirectory(zmm::String location);
 
    /// \brief Add an autoscan directory to the watch list.
    int addAutoscanDirectory(zmm::Ref<AutoscanDirectory> dir);


    /// \brief instructs ContentManager to reload scripting environment
#ifdef HAVE_JS
    void reloadScripting();
#endif


protected:
    ContentManager();
    
    static zmm::Ref<ContentManager> instance;
    
    void init();
    
#ifdef HAVE_JS
    void initScripting();
    void destroyScripting();
#endif
    //pthread_mutex_t last_modified_mutex;

    int ignore_unknown_extensions;
    zmm::Ref<Dictionary> extension_mimetype_map;
    zmm::Ref<Dictionary> mimetype_upnpclass_map;
    zmm::Ref<AutoscanList> autoscan_timed;
        

    /* don't use these, use the above methods */
    void _loadAccounting();
    void _addFile(zmm::String path, bool recursive=false, bool hidden=false);
    //void _addFile2(zmm::String path, bool recursive=0);
    void _removeObject(int objectID, bool all);
    
       
    void rescanDirectory(int objectID, int scanID, scan_mode_t scanMode); 
    void _rescanDirectory(int containerID, int scanID, scan_mode_t scanMode, scan_level_t scanLevel);
    /* for recursive addition */
    void addRecursive(zmm::String path, bool hidden=false);
    //void addRecursive2(zmm::Ref<DirCache> dirCache, zmm::String filename, bool recursive);

    zmm::String extension2mimetype(zmm::String extension);
    zmm::String mimetype2upnpclass(zmm::String mimeType);

#ifdef HAVE_JS  
    zmm::Ref<Scripting> scripting;
#endif
    
    void setLastModifiedTime(time_t lm);
    
    inline void signal() { cond->signal(); }
    static void *staticThreadProc(void *arg);
    void threadProc();
    
    void addTask(zmm::Ref<CMTask> task, bool lowPriority = false);

    zmm::Ref<CMAccounting> acct;
    
    pthread_t taskThread;
    static zmm::Ref<Mutex> mutex;
    zmm::Ref<Cond> cond;

    bool shutdownFlag;
    
    zmm::Ref<zmm::ObjectQueue<CMTask> > taskQueue1; // priority 1
    zmm::Ref<zmm::ObjectQueue<CMTask> > taskQueue2; // priority 2
    zmm::Ref<CMTask> currentTask;
    
    friend void CMAddFileTask::run();
    friend void CMRemoveObjectTask::run();
    friend void CMRescanDirectoryTask::run();
    friend void CMLoadAccountingTask::run();
};

#endif // __CONTENT_MANAGER_H__

